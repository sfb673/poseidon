


module Poseidon

  def self.included(base)
    base.class_eval do
      extend  ClassMethods
      include InstanceMethods
      class_variable_set :@@rdf_graph, RDF::Graph.new # unless defined?(@@rdf_graph)
      class_variable_set :@@rdf_props, {} # unless defined?(@@rdf_props)
      class_variable_set :@@rdf_includes, []
    end
  end

  module ClassMethods

    def poseidon?
      true
    end

    # Defines or returns the URI representing this class. There should be
    # one primary URI that is used throughout the RDF generated by
    # Poseidon. However, additional URIs can be added with
    # RDF relations like `sameAs`, 'equivalent', or 'seeAlso'.
    def self_uri(value=(getter=true;nil))
      class_variable_set :@@self_uri, RDF::URI(value) unless getter
      class_variable_get :@@self_uri
    end

    # Adds a type declaration triple to the class RDF graph.
    def rdf_type(target)
      class_variable_get(:@@rdf_graph) << [class_variable_get(:@@self_uri), RDF::type, RDF::URI(target)]
    end

    # Adds a "see also" declaration triple to the class RDF graph.
    def see_also(target)
      class_variable_get(:@@rdf_graph) << [class_variable_get(:@@self_uri), RDFS::seeAlso, RDF::URI(target)]
    end

    def rdf_props
      class_variable_get(:@@rdf_props)
    end

    def rdf_includes
      class_variable_get(:@@rdf_includes)
    end
    # @todo Class method for sameAs relation
    # @todo Class method for equivalent relation

    # ```ruby
    # rdf_property :name, type = (Class | URI | String)
    # ```

    # @todo change order to:
    # rdf_property :propertyName, :type, options
    # opts:
    #   uri  => The uri to use as verb
    #   value_conversion => a value conversion to use,
    #       e.g., type casting, URI wrapping, etc.

    def rdf_property(prop_name, type, opts={})
      new_prop_entry = {}
      new_prop_entry[:field] = prop_name
      effective_type = type
      if type.kind_of? Class
        if type.respond_to?(:self_uri)
          effective_type = type.self_uri
        end
      end
      unless effective_type.kind_of?(RDF::URI)
        effective_type = RDF::URI.new(effective_type)
      end
      new_prop_entry[:type]  = effective_type

      if opts.has_key?(:value_expression)
        new_prop_entry[:value_expression] = opts[:value_expression]
      end
      # @todo if there are options: apply them!
      class_variable_get(:@@rdf_props)[prop_name] = new_prop_entry
    end


    def rdf_include(member, relation_uri)
      class_variable_get(:@@rdf_includes) << [member.to_sym, relation_uri]
    end

    # Sets a scheme for the URI naming for instances of this class.
    # scheme should be a string. It may contain `#{}` constructs for
    # a later interpolation (interpolation will happen in the context
    # of single instances)
    def instance_uri_scheme(value=(getter=true;nil))
      class_variable_set :@@instance_uri_scheme, value unless getter
      class_variable_get :@@instance_uri_scheme
    end

    # adds RDF triples to the class RDF graph.
    def add_rdf(triples)
      class_variable_get(:@@rdf_graph) << triples
    end

    def triple_count
      class_variable_get(:@@rdf_graph).size
    end

    # Returns the internal RDF graph representation for this class,
    # containing all triples of this object.
    def as_rdf()
      result_graph = RDF::Graph.new class_variable_get(:@@rdf_graph)
      result_graph << [self_uri, RDF::type, RDFS['Class']]
    end

    # Returns a serialized format of the internal RDF graph representation
    # of this class.
    def to_rdf(opts = {:format => :ntriples})
      class_variable_get(:@@rdf_graph).dump(opts[:format])
    end

  end

  module InstanceMethods

    def setup_poseidon

    end

    # Sets an explicit URI for this object, or returns the given one
    # If an explicit URI is defined, it will be used.
    # If no explicit URI is given and the class has an instance URI scheme,
    # this will be used to generate the URI of the current object.
    def self_uri(value=(getter=true;nil))
      instance_variable_set(:@self_uri, RDF::URI(value)) unless getter
      if instance_variable_defined? :@self_uri
        return instance_variable_get :@self_uri
      else

        if instance_variable_defined? :@cached_self_uri
          return instance_variable_get :@cached_self_uri
        else

          if self.class.class_variable_defined?(:@@instance_uri_scheme)
            instance_variable_set :@cached_self_uri, RDF::URI(eval('"'+self.class.class_variable_get(:@@instance_uri_scheme)+'"'))
            return instance_variable_get :@cached_self_uri
          end
        end
      end
    end

    # Returns (or creates) an RDF graph for this object
    def rdf_graph
      @rdf_graph ||= RDF::Graph.new
    end

    # Adds a type declaration for this object
    def rdfs_type(target)
      rdf_graph << [get_self_uri, RDF::type, RDF::URI(target)]
    end

    #def rdfs_see_also(target)
    #  class_variable_get(:@@rdf_graph) << [class_variable_get(:@@self_uri), RDFS::seeAlso, RDF::URI(target)]
    #end

    # adds an include directive to this object. Such a directive tells
    # the RDF generator method to include RDF of other objects (typically
    # of members, aggregated objects or composition members).
    # object_to_include can be a single model object responding to
    # `as_rdf`, or it can be a collection of such objects.
    def rdf_include(object_to_include)
      # @todo
    end

    # Returns the internal RDF graph representation for this object,
    # containing all triples of this object.
    def as_rdf(opts = {})
      u = RDF::URI(self_uri)
      rdf_graph
      result_graph = RDF::Graph.new(rdf_graph)

      # add type to its class
      result_graph << [u, RDF::type, self.class.self_uri ]
      # add all property values
      if self.class.respond_to?(:rdf_props)
        self.class.rdf_props.each_pair do |prop_name, prop|
          # 1. add property entry
          # SELF, hasPROP, valueOfProp
          if respond_to?(prop[:field]) && !(send(prop[:field]).nil?)
            if prop.has_key?(:value_expression)
              result_graph << [self_uri, prop[:type], eval(prop[:value_expression]) ]
            else
              result_graph << [self_uri, prop[:type], RDF::Literal.new(send(prop[:field])) ]
            end
          end
        end
      end

      # add all rdf includes
      if self.class.respond_to?(:rdf_includes)
        self.class.rdf_includes.each do |incl_struct|
          incl = incl_struct[0]
          incl_uri = incl_struct[1]
          if respond_to?(incl) && !(incl.nil?)
            # okay, objects has something under this name
            member = send(incl)
            if member.kind_of?(Enumerable)
              member.each do |item|
                result_graph << item.as_rdf if item.respond_to? :as_rdf
                result_graph << [self_uri, RDF::URI(incl_uri), item.self_uri]
              end
            else
              result_graph << member.as_rdf if member.respond_to? :as_rdf
              result_graph << [self_uri, RDF::URI(incl_uri), member.self_uri]
            end
          end
        end
      end

      result_graph
    end

    # Returns a serialized format of the internal RDF graph representation
    # of this object.
    def to_rdf(opts = {:format => :ntriples})
      "Calling to_rdf for %s" % self.class.name
      asrdf = as_rdf
      all = 0
      s_miss = 0
      p_miss = 0
      o_miss = 0
      asrdf.each do |tr|
        all += 1
        s_miss +=1 if tr.subject.nil?
        p_miss +=1 if tr.predicate.nil?
        o_miss +=1 if tr.object.nil?
      end
      asrdf.dump(opts[:format], opts.select{ |k,v| [:base_uri, :prefixes].include?(k)})
    end

  end

end