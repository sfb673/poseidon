


module Poseidon

  def self.included(base)
    base.class_eval do
      extend  ClassMethods
      include InstanceMethods
      class_variable_set :@@rdf_graph, RDF::Graph.new # unless defined?(@@rdf_graph)
      class_variable_set :@@rdf_props, {} # unless defined?(@@rdf_props)
      class_variable_set :@@rdf_includes, []
      puts "RDF Graph included: %s" % class_variable_get(:@@rdf_graph).size
    end
  end

  module ClassMethods

    def poseidon?
      true
    end

    # Defines or returns the URI representing this class. There should be
    # one primary URI that is used throughout the RDF generated by
    # Poseidon. However, additional URIs can be added with
    # RDF relations like `sameAs`, 'equivalent', or 'seeAlso'.
    def self_uri(value=(getter=true;nil))
      class_variable_set :@@self_uri, RDF::URI(value) unless getter
      class_variable_get :@@self_uri
    end

    # Adds a type declaration triple to the class RDF graph.
    def rdf_type(target)
      #puts self.name
      #puts class_variable_get(:@@rdf_graph).size
      class_variable_get(:@@rdf_graph) << [class_variable_get(:@@self_uri), RDF::type, RDF::URI(target)]
      #puts class_variable_get(:@@rdf_graph).size
    end

    # Adds a "see also" declaration triple to the class RDF graph.
    def see_also(target)
      class_variable_get(:@@rdf_graph) << [class_variable_get(:@@self_uri), RDFS::seeAlso, RDF::URI(target)]
    end

    def rdf_props
      class_variable_get(:@@rdf_props)
    end

    def rdf_includes
      class_variable_get(:@@rdf_includes)
    end
    # @todo Class method for sameAs relation
    # @todo Class method for equivalent relation

    # ```ruby
    # rdf_property :name, type = (Class | URI | String)
    # ```

    # @todo change order to:
    # rdf_property :propertyName, :type, options
    # opts:
    #   uri  => The uri to use as verb
    #   value_conversion => a value conversion to use,
    #       e.g., type casting, URI wrapping, etc.

    def rdf_property(prop_name, type, opts={})
      new_prop_entry = {}
      new_prop_entry[:field] = prop_name
      effective_type = type
      if type.kind_of? Class
        if type.respond_to?(:self_uri)
          effective_type = type.self_uri
        end
      end
      unless effective_type.kind_of?(RDF::URI)
        effective_type = RDF::URI.new(effective_type)
      end
      new_prop_entry[:type]  = effective_type

      if opts.has_key?(:value_expression)
        new_prop_entry[:value_expression] = opts[:value_expression]
      end
      # @todo if there are options: apply them!
      # puts "Class of new prop entry:  %s" % new_prop_entry.class.name
      # puts "Class of props container: %s" % class_variable_get(:@@rdf_props).class.name

      class_variable_get(:@@rdf_props)[prop_name] = new_prop_entry
    end


    def rdf_include(member, relation_uri)
      class_variable_get(:@@rdf_includes) << [member.to_sym, relation_uri]
    end

    # Sets a scheme for the URI naming for instances of this class.
    # scheme should be a string. It may contain `#{}` constructs for
    # a later interpolation (interpolation will happen in the context
    # of single instances)
    def instance_uri_scheme(value=(getter=true;nil))
      class_variable_set :@@instance_uri_scheme, value unless getter
      class_variable_get :@@instance_uri_scheme
    end

    # adds RDF triples to the class RDF graph.
    def add_rdf(triples)
      class_variable_get(:@@rdf_graph) << triples
    end

    def triple_count
      class_variable_get(:@@rdf_graph).size
    end

    # Returns the internal RDF graph representation for this class,
    # containing all triples of this object.
    def as_rdf()
      class_variable_get(:@@rdf_graph)
    end

    # Returns a serialized format of the internal RDF graph representation
    # of this class.
    def to_rdf(opts = {:format => :ntriples})
      class_variable_get(:@@rdf_graph).dump(opts[:format])
    end

  end

  module InstanceMethods

    def setup_poseidon

    end

    # Sets an explicit URI for this object, or returns the given one
    # If an explicit URI is defined, it will be used.
    # If no explicit URI is given and the class has an instance URI scheme,
    # this will be used to generate the URI of the current object.
    def self_uri(value=(getter=true;nil))
      instance_variable_set(:@self_uri, RDF::URI(value)) unless getter
      if instance_variable_defined? :@self_uri
        return instance_variable_get :@self_uri
      else
        if self.class.class_variable_defined?(:@@instance_uri_scheme)
          return RDF::URI(eval('"'+self.class.class_variable_get(:@@instance_uri_scheme)+'"'))
        end
      end
    end

    # Returns (or creates) an RDF graph for this object
    def rdf_graph
      @rdf_graph ||= RDF::Graph.new
    end

    # Adds a type declaration for this object
    def rdfs_type(target)
      rdf_graph << [get_self_uri, RDF::type, RDF::URI(target)]
    end

    #def rdfs_see_also(target)
    #  class_variable_get(:@@rdf_graph) << [class_variable_get(:@@self_uri), RDFS::seeAlso, RDF::URI(target)]
    #end

    # adds an include directive to this object. Such a directive tells
    # the RDF generator method to include RDF of other objects (typically
    # of members, aggregated objects or composition members).
    # object_to_include can be a single model object responding to
    # `as_rdf`, or it can be a collection of such objects.
    def rdf_include(object_to_include)
      # @todo
    end

    # Returns the internal RDF graph representation for this object,
    # containing all triples of this object.
    def as_rdf(opts = {})
      rdf_graph
      result_graph = RDF::Graph.new(rdf_graph)

      puts "SELF: %s" % self.class.name
      puts " IUS: %s" % self.class.instance_uri_scheme

      # add type to its class
      result_graph << [ self_uri, RDF::type, self.class.self_uri ]

      # add all property values
            # puts "as_rdf // RDF property count: %i" % self.class.rdf_props.size
            # puts "code thinks we are in this class: %s" % self.class.name
            # puts "RDF_PROPS object id %i" % self.class.rdf_props.object_id
      if self.class.respond_to?(:rdf_props)
        self.class.rdf_props.each_pair do |prop_name, prop|
          # puts "Now looking into RDF props for this object: %s" % self.class.name
          # puts "  " + prop.inspect
          # 1. add property entry
          # SELF, hasPROP, valueOfProp
          puts "Keys: %s" % (prop.keys * ",")
          if respond_to?(prop[:field]) && !(send(prop[:field]).nil?)
            if prop.has_key?(:value_expression)
              puts "Evaluating expression %s in the context of %s" % [prop[:value_expression], self]
              puts"     = %s" % eval(prop[:value_expression])
              result_graph << [self_uri, prop[:type], eval(prop[:value_expression]) ]
              puts " SUB %s" % self_uri.class.name
              puts " PRE %s" % prop[:type].class.name
              puts " OBJ %s" % eval(prop[:value_expression]).class.name
            else
              result_graph << [self_uri, prop[:type], RDF::Literal.new(send(prop[:field])) ]
            end
          end
        end
      end

      # add all rdf includes
      if self.class.respond_to?(:rdf_includes)
        self.class.rdf_includes.each do |incl_struct|
          incl = incl_struct[0]
          incl_uri = incl_struct[1]
          puts "RDF include. %s" % incl.to_s
          if respond_to?(incl) && !(incl.nil?)
            # okay, objects has something under this name
            member = send(incl)
            if member.kind_of?(Enumerable)
              puts "MEMBER: %s" % member.class.name
              member.each do |item|
                puts "  ITEM: %s" % item.class.name
                result_graph << item.as_rdf if item.respond_to? :as_rdf
                result_graph << [self_uri, RDF::URI(incl_uri), item.self_uri]
              end
            else
              result_graph << member.as_rdf if member.respond_to? :as_rdf
              result_graph << [self_uri, RDF::URI(incl_uri), member.self_uri]
            end
          end
        end
      end

      result_graph
    end

    # Returns a serialized format of the internal RDF graph representation
    # of this object.
    def to_rdf(opts = {:format => :ntriples})
      as_rdf.dump(opts[:format], opts.select{ |k,v| [:base_uri, :prefixes].include?(k)})
    end

  end

end